<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="brainy-tree-node.html">

<!--
`brainy-tree` is a Polymer 1.x data tree web component.

This is a fork of [nuxeo-tree](https://www.webcomponents.org/element/nuxeo/nuxeo-ui-elements/nuxeo-tree)
with some changes related to handling external data mutations, and some useful methods regarding
common UX patterns like adding and deleting nodes.

### Features
- Collapsible tree re-rendering itself on outside data mutations
- The template represents the DOM to create for the nodes
- The `data` property specifies the model of a tree node
- The attribute `[toggle]` can be used to toggle a node
- State management methods making easy opening branches
- Tree node ID system based on depth and children count

### Template model

Tree node template is bound to template model of the following structure:
```js
{
  id: '0',         // generated node ID, useful to get subproperty path for splices
  item: {},        // data for given node
  isRoot: false,   // true if node is a tree root
  isLeaf: false,   // true if node does not have children
  opened: false    // true if node has been toggled to opened state
}
```

For example, given the following `data` object:

#### data.json
```json
{
  "name": "root",
  "children": [
    {
      "name": "a",
      "children": [
        {
          "name": "c",
          "children": [
            { "name": "foo" },
            { "name": "bar", "children": [{ "name": "baz" }] }
          ]
        }
      ]
    },
    {
      "name": "b",
      "children": [{ "name": "bee" }]
    }
  ]
}
```
The following code would render the tree:
```html
<brainy-tree data="[[data]]">
  <template>
    <template is="dom-if" if="[[!opened]]">
      <iron-icon icon="hardware:keyboard-arrow-right" toggle></iron-icon>
    </template>
    <template is="dom-if" if="[[opened]]">
      <iron-icon icon="hardware:keyboard-arrow-down" toggle></iron-icon>
    </template>
    <span select>My name is: [[item.name]]</span>
    <span>Am I a leaf? [[isLeaf]]</span>
  </template>
</brainy-tree>
```

@group Brainy Elements
@element brainy-tree
@demo demo/index.html
-->
<dom-module id="brainy-tree">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <content></content>

  </template>
  <script>
    var Brainy = window.Brainy || {};
    Brainy.Tree = Brainy.Tree || {};

    (function() {
      'use strict';

      var DELIMITER = '_';
      Brainy.Tree.ROOT_ID = '0';

      /**
       * Recursively walks through tree nodes ans sets IDs.
       * Root node ID is 0. For child nodes, ID is based:
       *  - current depth (not including root node's children)
       *  - index of a given node in it's parent `children` array
       *
       * @param {object} data - a data to process
       * @param {?string} index - an index to start from
       */
      function indexData(data, index) {
        index = index || Brainy.Tree.ROOT_ID;
        data.id = index;
        var ci;
        var i;
        var j;
        var children = data.children;
        if (children) {
          for (i = 0; i < children.length; i++) {
            ci = i + 1;
            j = index === Brainy.Tree.ROOT_ID ? ci.toString() : index + DELIMITER + ci;
            data.children[i].id = j;
            indexData(data.children[i], j);
          }
        }
      }

      /**
       * Recursively walks through tree nodes ans finds node with a given ID.
       *
       * @param {object} node - a node to start from
       * @param {string} id - an ID to search
       * @return {?object} - a node with a given ID
       */
      function searchTree(node, id) {
        var children = node.children;
        if (node.id === id) {
          return node;
        } else if (children && children.length) {
          var i;
          var result = null;
          for (i = 0; result === null && i < children.length; i++) {
            result = searchTree(children[i], id);
          }
          return result;
        }
        return null;
      }

      Polymer({
        is: 'brainy-tree',

        properties: {
          data: Object,
          _indexedData: Object,
          _template: Object
        },

        observers: [
          '_initialize(data.*)'
        ],

        /**
         * Initializes the tree whenever the data changes.
         *
         * @param {object} dataChange - an object describing `data` mutations
         */
        _initialize: function(dataChange) {
          var data;
          var state = this.saveOpenedState();
          if (dataChange && dataChange.base) {
            data = this._prepareData(dataChange.base);
            this.set('_indexedData', data);

            this._template = Polymer.dom(this).querySelector('template');
            if (this._root) {
              Polymer.dom(this).removeChild(this._root);
            }
            this._root = document.createElement('brainy-tree-node');
            this._root.dataHost = this.dataHost;
            this._root._template = this._template;
            this._root.data = data;
            this._root.dataset.id = Brainy.Tree.ROOT_ID;
            this._root.isRoot = true;
            Polymer.dom(this).appendChild(this._root);
            this._root.open().then(function() {
              this.restoreOpenedState(state);
            }.bind(this));
            Polymer.dom.flush();
          }
        },

        _prepareData: function(data) {
          var result = JSON.parse(JSON.stringify(data));
          indexData(result);
          return result;
        },

        /**
         * Opens a tree branch up to node with a given ID.
         *
         * @param {string} id - a node ID
         */
        openBranch: function(id) {
          var arr = id.split(DELIMITER);
          var len = arr.length;
          var n;
          var stack = [];
          for (var i = len; i >= 0; i--) {
            n = arr.slice(0, len - i).join(DELIMITER);
            if (n) {
              stack.push(n);
            }
          }
          this._openNodes(stack);
        },

        /**
         * Recursively opens a set of nodes.
         *
         * @param {Array<string>} ids - an array of IDs to open
         */
        _openNodes: function(ids) {
          if (!ids || ids.length === 0) {
            return;
          }
          var node = this.getDomNodeById(ids[0]);
          if (node) {
            node.open().then(function() {
              this._openNodes(Array.prototype.slice.call(ids, 1));
            }.bind(this));
          }
        },

        /**
         * Finds a DOM element by node ID.
         *
         * @param {string} id - a node ID
         * @return {HTMLElement} - a node having given ID
         */
        getDomNodeById: function(id) {
          return this.querySelector('[data-id="' + id + '"]');
        },

        /**
         * Finds a tree node by ID.
         *
         * @param {string} id - a node ID
         * @return {object} - a node having given ID
         */
        getNodeById: function(id) {
          return searchTree(this._indexedData, id);
        },

        /**
         * Finds a parent tree node by node ID.
         *
         * @param {string} id - a node ID
         * @return {object} - a node having given ID
         */
        getParentNodeById: function(id) {
          var parent;
          var arr = id.split(DELIMITER);
          var len = arr.length;
          // check for root node
          if (id !== Brainy.Tree.ROOT_ID) {
            var parentId = len > 1 ? arr.slice(0, len - 1).join(DELIMITER) : Brainy.Tree.ROOT_ID;
            parent = parentId === 0 ? this._indexedData : this.getNodeById(parentId);
          }
          return parent;
        },

        /**
         * Finds an index of a given node in it's parent `children` array.
         *
         * @param {object} parent - a parent node object
         * @param {string} id - a node ID
         * @return {number} - an index
         */
        getChildIndexById: function(parent, id) {
          var children = parent.children;
          if (children && children.length) {
            for (var i = 0; i < children.length; i++) {
              if (children[i].id === id) {
                return i;
              }
            }
            return -1;
          }
        },

        /**
         * Constructs a path to `children` for a given tree node.
         *
         * @param {string} root - a name of property being bound to `data`
         * @param {object} node - a node object
         * @return {?string} - a path which can be used to call `splice` method.
         */
        getPathForNode: function(root, node) {
          // fail if root property name is not passed
          if (!root) {
            return null;
          }
          var id = node ? node.id : Brainy.Tree.ROOT_ID;
          var path = '';
          var result;
          if (id !== Brainy.Tree.ROOT_ID) {
            path = id
              .split(DELIMITER)
              .map(function(n) {
                return Number(n) - 1;
              })
              .join('.children.');
          }
          result = path ? root + '.children.' + path : root;
          return result + '.children';
        },

        /**
         * Constructs array of currently opened node ID's.
         * Doing this on `detached` would allow to store state, e. g. in localStorage.
         *
         * @return {Array<string>} - an array of IDs to save
         */
        saveOpenedState: function() {
          return Array.prototype.slice.call(this.querySelectorAll('brainy-tree-node')).reduce(function(list, node) {
            if (node.opened) {
              list.push(node.dataset.id);
            }
            return list;
          }, []);
        },

        /**
         * Restore tree state from array of node ID's.
         *
         * @param {Array<string>} state - an array of IDs to restore
         */
        restoreOpenedState: function(state) {
          this._openNodes(state);
        }
      });
    })();
  </script>
</dom-module>
